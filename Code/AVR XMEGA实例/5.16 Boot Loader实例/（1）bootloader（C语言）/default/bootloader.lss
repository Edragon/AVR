
bootloader.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000996  00020000  00020000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000010  00802000  00020996  00000a2a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000401  00802010  00802010  00000a3a  2**0
                  ALLOC
  3 .debug_aranges 00000040  00000000  00000000  00000a40  2**3
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000316  00000000  00000000  00000a80  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000018a9  00000000  00000000  00000d96  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000277  00000000  00000000  0000263f  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000743  00000000  00000000  000028b6  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000240  00000000  00000000  00002ffc  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000ede  00000000  00000000  0000323c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000006eb  00000000  00000000  0000411a  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000030  00000000  00000000  00004805  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00020000 <__vectors>:
   20000:	0d 94 fa 00 	jmp	0x201f4	; 0x201f4 <__ctors_end>
   20004:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20008:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   2000c:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20010:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20014:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20018:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   2001c:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20020:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20024:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20028:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   2002c:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20030:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20034:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20038:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   2003c:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20040:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20044:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20048:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   2004c:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20050:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20054:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20058:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   2005c:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20060:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20064:	0d 94 1c 03 	jmp	0x20638	; 0x20638 <__vector_25>
   20068:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   2006c:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20070:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20074:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20078:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   2007c:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20080:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20084:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20088:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   2008c:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20090:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20094:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20098:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   2009c:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   200a0:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   200a4:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   200a8:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   200ac:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   200b0:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   200b4:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   200b8:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   200bc:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   200c0:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   200c4:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   200c8:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   200cc:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   200d0:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   200d4:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   200d8:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   200dc:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   200e0:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   200e4:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   200e8:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   200ec:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   200f0:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   200f4:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   200f8:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   200fc:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20100:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20104:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20108:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   2010c:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20110:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20114:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20118:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   2011c:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20120:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20124:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20128:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   2012c:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20130:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20134:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20138:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   2013c:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20140:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20144:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20148:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   2014c:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20150:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20154:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20158:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   2015c:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20160:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20164:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20168:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   2016c:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20170:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20174:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20178:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   2017c:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20180:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20184:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20188:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   2018c:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20190:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20194:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   20198:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   2019c:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   201a0:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   201a4:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   201a8:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   201ac:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   201b0:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   201b4:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   201b8:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   201bc:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   201c0:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   201c4:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   201c8:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   201cc:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   201d0:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   201d4:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   201d8:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   201dc:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   201e0:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   201e4:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   201e8:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   201ec:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>
   201f0:	0d 94 20 01 	jmp	0x20240	; 0x20240 <__bad_interrupt>

000201f4 <__ctors_end>:
   201f4:	11 24       	eor	r1, r1
   201f6:	1f be       	out	0x3f, r1	; 63
   201f8:	cf ef       	ldi	r28, 0xFF	; 255
   201fa:	df e3       	ldi	r29, 0x3F	; 63
   201fc:	de bf       	out	0x3e, r29	; 62
   201fe:	cd bf       	out	0x3d, r28	; 61
   20200:	01 e0       	ldi	r16, 0x01	; 1
   20202:	0c bf       	out	0x3c, r16	; 60
   20204:	18 be       	out	0x38, r1	; 56
   20206:	19 be       	out	0x39, r1	; 57
   20208:	1a be       	out	0x3a, r1	; 58
   2020a:	1b be       	out	0x3b, r1	; 59

0002020c <__do_copy_data>:
   2020c:	10 e2       	ldi	r17, 0x20	; 32
   2020e:	a0 e0       	ldi	r26, 0x00	; 0
   20210:	b0 e2       	ldi	r27, 0x20	; 32
   20212:	e6 e9       	ldi	r30, 0x96	; 150
   20214:	f9 e0       	ldi	r31, 0x09	; 9
   20216:	02 e0       	ldi	r16, 0x02	; 2
   20218:	0b bf       	out	0x3b, r16	; 59
   2021a:	02 c0       	rjmp	.+4      	; 0x20220 <__do_copy_data+0x14>
   2021c:	07 90       	elpm	r0, Z+
   2021e:	0d 92       	st	X+, r0
   20220:	a0 31       	cpi	r26, 0x10	; 16
   20222:	b1 07       	cpc	r27, r17
   20224:	d9 f7       	brne	.-10     	; 0x2021c <__do_copy_data+0x10>
   20226:	1b be       	out	0x3b, r1	; 59

00020228 <__do_clear_bss>:
   20228:	14 e2       	ldi	r17, 0x24	; 36
   2022a:	a0 e1       	ldi	r26, 0x10	; 16
   2022c:	b0 e2       	ldi	r27, 0x20	; 32
   2022e:	01 c0       	rjmp	.+2      	; 0x20232 <.do_clear_bss_start>

00020230 <.do_clear_bss_loop>:
   20230:	1d 92       	st	X+, r1

00020232 <.do_clear_bss_start>:
   20232:	a1 31       	cpi	r26, 0x11	; 17
   20234:	b1 07       	cpc	r27, r17
   20236:	e1 f7       	brne	.-8      	; 0x20230 <.do_clear_bss_loop>
   20238:	0f 94 d3 02 	call	0x205a6	; 0x205a6 <main>
   2023c:	0d 94 c9 04 	jmp	0x20992	; 0x20992 <_exit>

00020240 <__bad_interrupt>:
   20240:	0d 94 00 00 	jmp	0x20000	; 0x20000 <__vectors>

00020244 <uart_putc>:
| Returns     : 
|
+------------------------------------------------------------------------------
*/
void uart_putc(unsigned char c)
{
   20244:	1f 93       	push	r17
   20246:	18 2f       	mov	r17, r24
    if(c == '\n')
   20248:	8a 30       	cpi	r24, 0x0A	; 10
   2024a:	19 f4       	brne	.+6      	; 0x20252 <uart_putc+0xe>
        uart_putc('\r');
   2024c:	8d e0       	ldi	r24, 0x0D	; 13
   2024e:	0f 94 22 01 	call	0x20244	; 0x20244 <uart_putc>

    /* wait until transmit buffer is empty */
    while(!(USART.STATUS & USART_DREIF_bm));
   20252:	80 91 a1 08 	lds	r24, 0x08A1
   20256:	85 ff       	sbrs	r24, 5
   20258:	fc cf       	rjmp	.-8      	; 0x20252 <uart_putc+0xe>

    /* send next byte */
    USART.DATA = c;
   2025a:	10 93 a0 08 	sts	0x08A0, r17
}
   2025e:	1f 91       	pop	r17
   20260:	08 95       	ret

00020262 <uart_putc_hex>:
| Returns     : 
|
+------------------------------------------------------------------------------
*/
void uart_putc_hex(unsigned char b)
{
   20262:	1f 93       	push	r17
   20264:	18 2f       	mov	r17, r24
    /* upper nibble */
    if((b >> 4) < 0x0a)
   20266:	82 95       	swap	r24
   20268:	8f 70       	andi	r24, 0x0F	; 15
   2026a:	8a 30       	cpi	r24, 0x0A	; 10
   2026c:	10 f4       	brcc	.+4      	; 0x20272 <uart_putc_hex+0x10>
        uart_putc((b >> 4) + '0');
   2026e:	80 5d       	subi	r24, 0xD0	; 208
   20270:	01 c0       	rjmp	.+2      	; 0x20274 <uart_putc_hex+0x12>
    else
        uart_putc((b >> 4) - 0x0a + 'a');
   20272:	89 5a       	subi	r24, 0xA9	; 169
   20274:	0f 94 22 01 	call	0x20244	; 0x20244 <uart_putc>

    /* lower nibble */
    if((b & 0x0f) < 0x0a)
   20278:	81 2f       	mov	r24, r17
   2027a:	90 e0       	ldi	r25, 0x00	; 0
   2027c:	8f 70       	andi	r24, 0x0F	; 15
   2027e:	90 70       	andi	r25, 0x00	; 0
   20280:	21 2f       	mov	r18, r17
   20282:	2f 70       	andi	r18, 0x0F	; 15
   20284:	0a 97       	sbiw	r24, 0x0a	; 10
   20286:	1c f4       	brge	.+6      	; 0x2028e <uart_putc_hex+0x2c>
        uart_putc((b & 0x0f) + '0');
   20288:	82 2f       	mov	r24, r18
   2028a:	80 5d       	subi	r24, 0xD0	; 208
   2028c:	02 c0       	rjmp	.+4      	; 0x20292 <uart_putc_hex+0x30>
    else
        uart_putc((b & 0x0f) - 0x0a + 'a');
   2028e:	82 2f       	mov	r24, r18
   20290:	89 5a       	subi	r24, 0xA9	; 169
   20292:	0f 94 22 01 	call	0x20244	; 0x20244 <uart_putc>
}
   20296:	1f 91       	pop	r17
   20298:	08 95       	ret

0002029a <uart_putw_hex>:
| Returns     : 
|
+------------------------------------------------------------------------------
*/
void uart_putw_hex(unsigned int w)
{
   2029a:	1f 93       	push	r17
   2029c:	18 2f       	mov	r17, r24
    uart_putc_hex((unsigned char) (w >> 8));
   2029e:	89 2f       	mov	r24, r25
   202a0:	0f 94 31 01 	call	0x20262	; 0x20262 <uart_putc_hex>
    uart_putc_hex((unsigned char) (w & 0xff));
   202a4:	81 2f       	mov	r24, r17
   202a6:	0f 94 31 01 	call	0x20262	; 0x20262 <uart_putc_hex>
}
   202aa:	1f 91       	pop	r17
   202ac:	08 95       	ret

000202ae <uart_putdw_hex>:
| Returns     : 
|
+------------------------------------------------------------------------------
*/
void uart_putdw_hex(unsigned long dw)
{
   202ae:	ef 92       	push	r14
   202b0:	ff 92       	push	r15
   202b2:	0f 93       	push	r16
   202b4:	1f 93       	push	r17
   202b6:	7b 01       	movw	r14, r22
   202b8:	8c 01       	movw	r16, r24
    uart_putw_hex((unsigned int) (dw >> 16));
   202ba:	c8 01       	movw	r24, r16
   202bc:	aa 27       	eor	r26, r26
   202be:	bb 27       	eor	r27, r27
   202c0:	0f 94 4d 01 	call	0x2029a	; 0x2029a <uart_putw_hex>
    uart_putw_hex((unsigned int) (dw & 0xffff));
   202c4:	c7 01       	movw	r24, r14
   202c6:	0f 94 4d 01 	call	0x2029a	; 0x2029a <uart_putw_hex>
}
   202ca:	1f 91       	pop	r17
   202cc:	0f 91       	pop	r16
   202ce:	ff 90       	pop	r15
   202d0:	ef 90       	pop	r14
   202d2:	08 95       	ret

000202d4 <uart_putw_dec>:
| Returns     : 
|
+------------------------------------------------------------------------------
*/
void uart_putw_dec(unsigned int w)
{
   202d4:	cf 92       	push	r12
   202d6:	df 92       	push	r13
   202d8:	ff 92       	push	r15
   202da:	0f 93       	push	r16
   202dc:	1f 93       	push	r17
   202de:	cf 93       	push	r28
   202e0:	df 93       	push	r29
   202e2:	6c 01       	movw	r12, r24
   202e4:	c0 e1       	ldi	r28, 0x10	; 16
   202e6:	d7 e2       	ldi	r29, 0x27	; 39
   202e8:	40 e0       	ldi	r20, 0x00	; 0
   202ea:	00 e0       	ldi	r16, 0x00	; 0
   202ec:	10 e0       	ldi	r17, 0x00	; 0
    unsigned int num = 10000;
    unsigned char started = 0;

    while(num > 0)
    {
        unsigned char b = w / num;
   202ee:	c6 01       	movw	r24, r12
   202f0:	be 01       	movw	r22, r28
   202f2:	0f 94 93 04 	call	0x20926	; 0x20926 <__udivmodhi4>
   202f6:	f6 2e       	mov	r15, r22
        if(b > 0 || started || num == 1)
   202f8:	66 23       	and	r22, r22
   202fa:	29 f4       	brne	.+10     	; 0x20306 <uart_putw_dec+0x32>
   202fc:	44 23       	and	r20, r20
   202fe:	19 f4       	brne	.+6      	; 0x20306 <uart_putw_dec+0x32>
   20300:	c1 30       	cpi	r28, 0x01	; 1
   20302:	d1 05       	cpc	r29, r1
   20304:	29 f4       	brne	.+10     	; 0x20310 <uart_putw_dec+0x3c>
        {
            uart_putc('0' + b);
   20306:	8f 2d       	mov	r24, r15
   20308:	80 5d       	subi	r24, 0xD0	; 208
   2030a:	0f 94 22 01 	call	0x20244	; 0x20244 <uart_putc>
   2030e:	41 e0       	ldi	r20, 0x01	; 1
            started = 1;
        }
        w -= b * num;

        num /= 10;
   20310:	ce 01       	movw	r24, r28
   20312:	6a e0       	ldi	r22, 0x0A	; 10
   20314:	70 e0       	ldi	r23, 0x00	; 0
   20316:	0f 94 93 04 	call	0x20926	; 0x20926 <__udivmodhi4>
   2031a:	0f 5f       	subi	r16, 0xFF	; 255
   2031c:	1f 4f       	sbci	r17, 0xFF	; 255
void uart_putw_dec(unsigned int w)
{
    unsigned int num = 10000;
    unsigned char started = 0;

    while(num > 0)
   2031e:	05 30       	cpi	r16, 0x05	; 5
   20320:	11 05       	cpc	r17, r1
   20322:	71 f0       	breq	.+28     	; 0x20340 <uart_putw_dec+0x6c>
        if(b > 0 || started || num == 1)
        {
            uart_putc('0' + b);
            started = 1;
        }
        w -= b * num;
   20324:	8f 2d       	mov	r24, r15
   20326:	90 e0       	ldi	r25, 0x00	; 0
   20328:	9c 01       	movw	r18, r24
   2032a:	2c 9f       	mul	r18, r28
   2032c:	c0 01       	movw	r24, r0
   2032e:	2d 9f       	mul	r18, r29
   20330:	90 0d       	add	r25, r0
   20332:	3c 9f       	mul	r19, r28
   20334:	90 0d       	add	r25, r0
   20336:	11 24       	eor	r1, r1
   20338:	c8 1a       	sub	r12, r24
   2033a:	d9 0a       	sbc	r13, r25
   2033c:	eb 01       	movw	r28, r22
   2033e:	d7 cf       	rjmp	.-82     	; 0x202ee <uart_putw_dec+0x1a>

        num /= 10;
    }
}
   20340:	df 91       	pop	r29
   20342:	cf 91       	pop	r28
   20344:	1f 91       	pop	r17
   20346:	0f 91       	pop	r16
   20348:	ff 90       	pop	r15
   2034a:	df 90       	pop	r13
   2034c:	cf 90       	pop	r12
   2034e:	08 95       	ret

00020350 <uart_putdw_dec>:
| Returns     : 
|
+------------------------------------------------------------------------------
*/
void uart_putdw_dec(unsigned long dw)
{
   20350:	4f 92       	push	r4
   20352:	5f 92       	push	r5
   20354:	6f 92       	push	r6
   20356:	7f 92       	push	r7
   20358:	8f 92       	push	r8
   2035a:	9f 92       	push	r9
   2035c:	af 92       	push	r10
   2035e:	bf 92       	push	r11
   20360:	cf 92       	push	r12
   20362:	df 92       	push	r13
   20364:	ef 92       	push	r14
   20366:	ff 92       	push	r15
   20368:	0f 93       	push	r16
   2036a:	1f 93       	push	r17
   2036c:	cf 93       	push	r28
   2036e:	df 93       	push	r29
   20370:	5b 01       	movw	r10, r22
   20372:	6c 01       	movw	r12, r24
   20374:	e1 2c       	mov	r14, r1
   20376:	9a ec       	ldi	r25, 0xCA	; 202
   20378:	f9 2e       	mov	r15, r25
   2037a:	9a e9       	ldi	r25, 0x9A	; 154
   2037c:	09 2f       	mov	r16, r25
   2037e:	9b e3       	ldi	r25, 0x3B	; 59
   20380:	19 2f       	mov	r17, r25
   20382:	44 24       	eor	r4, r4
   20384:	c0 e0       	ldi	r28, 0x00	; 0
   20386:	d0 e0       	ldi	r29, 0x00	; 0
    unsigned long num = 1000000000;
    unsigned char started = 0;

    while(num > 0)
    {
        unsigned char b = dw / num;
   20388:	c6 01       	movw	r24, r12
   2038a:	b5 01       	movw	r22, r10
   2038c:	a8 01       	movw	r20, r16
   2038e:	97 01       	movw	r18, r14
   20390:	0f 94 a7 04 	call	0x2094e	; 0x2094e <__udivmodsi4>
   20394:	92 2e       	mov	r9, r18
        if(b > 0 || started || num == 1)
   20396:	22 23       	and	r18, r18
   20398:	41 f4       	brne	.+16     	; 0x203aa <uart_putdw_dec+0x5a>
   2039a:	44 20       	and	r4, r4
   2039c:	31 f4       	brne	.+12     	; 0x203aa <uart_putdw_dec+0x5a>
   2039e:	81 e0       	ldi	r24, 0x01	; 1
   203a0:	e8 16       	cp	r14, r24
   203a2:	f1 04       	cpc	r15, r1
   203a4:	01 05       	cpc	r16, r1
   203a6:	11 05       	cpc	r17, r1
   203a8:	31 f4       	brne	.+12     	; 0x203b6 <uart_putdw_dec+0x66>
        {
            uart_putc('0' + b);
   203aa:	89 2d       	mov	r24, r9
   203ac:	80 5d       	subi	r24, 0xD0	; 208
   203ae:	0f 94 22 01 	call	0x20244	; 0x20244 <uart_putc>
   203b2:	44 24       	eor	r4, r4
   203b4:	43 94       	inc	r4
            started = 1;
        }
        dw -= b * num;

        num /= 10;
   203b6:	c8 01       	movw	r24, r16
   203b8:	b7 01       	movw	r22, r14
   203ba:	2a e0       	ldi	r18, 0x0A	; 10
   203bc:	30 e0       	ldi	r19, 0x00	; 0
   203be:	40 e0       	ldi	r20, 0x00	; 0
   203c0:	50 e0       	ldi	r21, 0x00	; 0
   203c2:	0f 94 a7 04 	call	0x2094e	; 0x2094e <__udivmodsi4>
   203c6:	82 2e       	mov	r8, r18
   203c8:	73 2e       	mov	r7, r19
   203ca:	64 2e       	mov	r6, r20
   203cc:	55 2e       	mov	r5, r21
   203ce:	21 96       	adiw	r28, 0x01	; 1
void uart_putdw_dec(unsigned long dw)
{
    unsigned long num = 1000000000;
    unsigned char started = 0;

    while(num > 0)
   203d0:	ca 30       	cpi	r28, 0x0A	; 10
   203d2:	d1 05       	cpc	r29, r1
   203d4:	a9 f0       	breq	.+42     	; 0x20400 <uart_putdw_dec+0xb0>
        if(b > 0 || started || num == 1)
        {
            uart_putc('0' + b);
            started = 1;
        }
        dw -= b * num;
   203d6:	69 2d       	mov	r22, r9
   203d8:	70 e0       	ldi	r23, 0x00	; 0
   203da:	80 e0       	ldi	r24, 0x00	; 0
   203dc:	90 e0       	ldi	r25, 0x00	; 0
   203de:	a8 01       	movw	r20, r16
   203e0:	97 01       	movw	r18, r14
   203e2:	0f 94 74 04 	call	0x208e8	; 0x208e8 <__mulsi3>
   203e6:	a6 1a       	sub	r10, r22
   203e8:	b7 0a       	sbc	r11, r23
   203ea:	c8 0a       	sbc	r12, r24
   203ec:	d9 0a       	sbc	r13, r25
   203ee:	28 2d       	mov	r18, r8
   203f0:	37 2d       	mov	r19, r7
   203f2:	46 2d       	mov	r20, r6
   203f4:	55 2d       	mov	r21, r5
   203f6:	c9 01       	movw	r24, r18
   203f8:	da 01       	movw	r26, r20
   203fa:	7c 01       	movw	r14, r24
   203fc:	8d 01       	movw	r16, r26
   203fe:	c4 cf       	rjmp	.-120    	; 0x20388 <uart_putdw_dec+0x38>

        num /= 10;
    }
}
   20400:	df 91       	pop	r29
   20402:	cf 91       	pop	r28
   20404:	1f 91       	pop	r17
   20406:	0f 91       	pop	r16
   20408:	ff 90       	pop	r15
   2040a:	ef 90       	pop	r14
   2040c:	df 90       	pop	r13
   2040e:	cf 90       	pop	r12
   20410:	bf 90       	pop	r11
   20412:	af 90       	pop	r10
   20414:	9f 90       	pop	r9
   20416:	8f 90       	pop	r8
   20418:	7f 90       	pop	r7
   2041a:	6f 90       	pop	r6
   2041c:	5f 90       	pop	r5
   2041e:	4f 90       	pop	r4
   20420:	08 95       	ret

00020422 <uart_puts>:
| Returns     : 
|
+------------------------------------------------------------------------------
*/
void uart_puts(const char* str)
{
   20422:	cf 93       	push	r28
   20424:	df 93       	push	r29
   20426:	ec 01       	movw	r28, r24
   20428:	03 c0       	rjmp	.+6      	; 0x20430 <uart_puts+0xe>
    while(*str)
        uart_putc(*str++);
   2042a:	21 96       	adiw	r28, 0x01	; 1
   2042c:	0f 94 22 01 	call	0x20244	; 0x20244 <uart_putc>
|
+------------------------------------------------------------------------------
*/
void uart_puts(const char* str)
{
    while(*str)
   20430:	88 81       	ld	r24, Y
   20432:	88 23       	and	r24, r24
   20434:	d1 f7       	brne	.-12     	; 0x2042a <uart_puts+0x8>
        uart_putc(*str++);
}
   20436:	df 91       	pop	r29
   20438:	cf 91       	pop	r28
   2043a:	08 95       	ret

0002043c <uart_getc>:
+------------------------------------------------------------------------------
*/
unsigned char uart_getc(void)
{
    /* wait until receive buffer is full */
    while(!(USART.STATUS & USART_RXCIF_bm));
   2043c:	80 91 a1 08 	lds	r24, 0x08A1
   20440:	87 ff       	sbrs	r24, 7
   20442:	fc cf       	rjmp	.-8      	; 0x2043c <uart_getc>

    unsigned char b = USART.DATA;
   20444:	80 91 a0 08 	lds	r24, 0x08A0
    if(b == '\r')
   20448:	8d 30       	cpi	r24, 0x0D	; 13
   2044a:	09 f4       	brne	.+2      	; 0x2044e <uart_getc+0x12>
   2044c:	8a e0       	ldi	r24, 0x0A	; 10
        b = '\n';
		
    return b;
}
   2044e:	08 95       	ret

00020450 <TC0_ConfigClockSource>:
 *
 *  \param tc              Timer/Counter module instance.
 *  \param clockSelection  Timer/Counter clock source setting.
 */
void TC0_ConfigClockSource( volatile TC0_t * tc, TC_CLKSEL_t clockSelection )
{
   20450:	fc 01       	movw	r30, r24
	tc->CTRLA = ( tc->CTRLA & ~TC0_CLKSEL_gm ) | clockSelection;
   20452:	80 81       	ld	r24, Z
   20454:	80 7f       	andi	r24, 0xF0	; 240
   20456:	86 2b       	or	r24, r22
   20458:	80 83       	st	Z, r24
}
   2045a:	08 95       	ret

0002045c <TC1_ConfigClockSource>:
 *
 *  \param tc              Timer/Counter module instance.
 *  \param clockSelection  Timer/Counter clock source setting.
 */
void TC1_ConfigClockSource( volatile TC1_t * tc, TC_CLKSEL_t clockSelection )
{
   2045c:	fc 01       	movw	r30, r24
	tc->CTRLA = ( tc->CTRLA & ~TC1_CLKSEL_gm ) | clockSelection;
   2045e:	80 81       	ld	r24, Z
   20460:	80 7f       	andi	r24, 0xF0	; 240
   20462:	86 2b       	or	r24, r22
   20464:	80 83       	st	Z, r24
}
   20466:	08 95       	ret

00020468 <TC0_ConfigWGM>:
 *
 *  \param tc    Timer/Counter module instance.
 *  \param wgm   Waveform generation mode.
 */
void TC0_ConfigWGM( volatile TC0_t * tc, TC_WGMODE_t wgm )
{
   20468:	fc 01       	movw	r30, r24
	tc->CTRLB = ( tc->CTRLB & ~TC0_WGMODE_gm ) | wgm;
   2046a:	81 81       	ldd	r24, Z+1	; 0x01
   2046c:	88 7f       	andi	r24, 0xF8	; 248
   2046e:	86 2b       	or	r24, r22
   20470:	81 83       	std	Z+1, r24	; 0x01
}
   20472:	08 95       	ret

00020474 <TC1_ConfigWGM>:
 *
 *  \param tc    Timer/Counter module instance.
 *  \param wgm   Waveform generation mode.
 */
void TC1_ConfigWGM( volatile TC1_t * tc, TC_WGMODE_t wgm )
{
   20474:	fc 01       	movw	r30, r24
	tc->CTRLB = ( tc->CTRLB & ~TC1_WGMODE_gm ) | wgm;
   20476:	81 81       	ldd	r24, Z+1	; 0x01
   20478:	88 7f       	andi	r24, 0xF8	; 248
   2047a:	86 2b       	or	r24, r22
   2047c:	81 83       	std	Z+1, r24	; 0x01
}
   2047e:	08 95       	ret

00020480 <TC0_ConfigInputCapture>:
 *
 *  \param tc               Timer/Counter module instance.
 *  \param eventSource      Event source selection.
 */
void TC0_ConfigInputCapture( volatile TC0_t * tc, TC_EVSEL_t eventSource )
{
   20480:	fc 01       	movw	r30, r24
	tc->CTRLD = ( tc->CTRLD & ~( TC0_EVSEL_gm | TC0_EVACT_gm ) ) |
   20482:	83 81       	ldd	r24, Z+3	; 0x03
   20484:	80 71       	andi	r24, 0x10	; 16
   20486:	80 62       	ori	r24, 0x20	; 32
   20488:	86 2b       	or	r24, r22
   2048a:	83 83       	std	Z+3, r24	; 0x03
	            eventSource |
	            TC_EVACT_CAPT_gc;
}
   2048c:	08 95       	ret

0002048e <TC1_ConfigInputCapture>:
 *
 *  \param tc               Timer/Counter module instance.
 *  \param eventSource      Event source selection.
 */
void TC1_ConfigInputCapture( volatile TC1_t * tc, TC_EVSEL_t eventSource )
{
   2048e:	fc 01       	movw	r30, r24
	tc->CTRLD = ( tc->CTRLD & ~( TC1_EVSEL_gm | TC1_EVACT_gm ) ) |
   20490:	83 81       	ldd	r24, Z+3	; 0x03
   20492:	80 71       	andi	r24, 0x10	; 16
   20494:	80 62       	ori	r24, 0x20	; 32
   20496:	86 2b       	or	r24, r22
   20498:	83 83       	std	Z+3, r24	; 0x03
	            eventSource |
	            TC_EVACT_CAPT_gc;
}
   2049a:	08 95       	ret

0002049c <TC0_EnableCCChannels>:
 *
 *  \param tc               Timer/Counter module instance.
 *  \param enableMask       Mask of channels to enable.
 */
void TC0_EnableCCChannels( volatile TC0_t * tc, uint8_t enableMask )
{
   2049c:	fc 01       	movw	r30, r24
	/* Make sure only CCxEN bits are set in enableMask. */
	enableMask &= ( TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm );

	/* Enable channels. */
	tc->CTRLB |= enableMask;
   2049e:	81 81       	ldd	r24, Z+1	; 0x01
   204a0:	60 7f       	andi	r22, 0xF0	; 240
   204a2:	86 2b       	or	r24, r22
   204a4:	81 83       	std	Z+1, r24	; 0x01
}
   204a6:	08 95       	ret

000204a8 <TC1_EnableCCChannels>:
 *
 *  \param tc               Timer/Counter module instance.
 *  \param enableMask       Mask of channels to enable.
 */
void TC1_EnableCCChannels( volatile TC1_t * tc, uint8_t enableMask )
{
   204a8:	fc 01       	movw	r30, r24
	/* Make sure only CCxEN bits are set in enableMask. */
	enableMask &= ( TC1_CCAEN_bm | TC1_CCBEN_bm );

	/* Enable channels. */
	tc->CTRLB |= enableMask;
   204aa:	81 81       	ldd	r24, Z+1	; 0x01
   204ac:	60 73       	andi	r22, 0x30	; 48
   204ae:	86 2b       	or	r24, r22
   204b0:	81 83       	std	Z+1, r24	; 0x01
}
   204b2:	08 95       	ret

000204b4 <TC0_DisableCCChannels>:
 *
 *  \param tc               Timer/Counter module instance.
 *  \param disableMask      Mask of channels to disable.
 */
void TC0_DisableCCChannels( volatile TC0_t * tc, uint8_t disableMask )
{
   204b4:	fc 01       	movw	r30, r24
	/* Make sure only CCxEN bits are set in disableMask. */
	disableMask &= ( TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm );

	/* Disable channels. */
	tc->CTRLB &= ~disableMask;
   204b6:	81 81       	ldd	r24, Z+1	; 0x01
   204b8:	60 7f       	andi	r22, 0xF0	; 240
   204ba:	60 95       	com	r22
   204bc:	86 23       	and	r24, r22
   204be:	81 83       	std	Z+1, r24	; 0x01
}
   204c0:	08 95       	ret

000204c2 <TC1_DisableCCChannels>:
 *
 *  \param tc               Timer/Counter module instance.
 *  \param disableMask      Mask of channels to disable.
 */
void TC1_DisableCCChannels( volatile TC1_t * tc, uint8_t disableMask )
{
   204c2:	fc 01       	movw	r30, r24
	/* Make sure only CCxEN bits are set in disableMask. */
	disableMask &= ( TC1_CCAEN_bm | TC1_CCBEN_bm );

	/* Disable channels. */
	tc->CTRLB &= ~disableMask;
   204c4:	81 81       	ldd	r24, Z+1	; 0x01
   204c6:	60 73       	andi	r22, 0x30	; 48
   204c8:	60 95       	com	r22
   204ca:	86 23       	and	r24, r22
   204cc:	81 83       	std	Z+1, r24	; 0x01
}
   204ce:	08 95       	ret

000204d0 <TC0_SetOverflowIntLevel>:
 *
 *  \param tc               Timer/Counter module instance.
 *  \param intLevel         New overflow interrupt level.
 */
void TC0_SetOverflowIntLevel( volatile TC0_t * tc, TC_OVFINTLVL_t intLevel )
{
   204d0:	fc 01       	movw	r30, r24
	tc->INTCTRLA = ( tc->INTCTRLA & ~TC0_OVFINTLVL_gm ) | intLevel;
   204d2:	86 81       	ldd	r24, Z+6	; 0x06
   204d4:	8c 7f       	andi	r24, 0xFC	; 252
   204d6:	86 2b       	or	r24, r22
   204d8:	86 83       	std	Z+6, r24	; 0x06
}
   204da:	08 95       	ret

000204dc <TC1_SetOverflowIntLevel>:
 *
 *  \param tc               Timer/Counter module instance.
 *  \param intLevel         New overflow interrupt level.
 */
void TC1_SetOverflowIntLevel( volatile TC1_t * tc, TC_OVFINTLVL_t intLevel )
{
   204dc:	fc 01       	movw	r30, r24
	tc->INTCTRLA = ( tc->INTCTRLA & ~TC1_OVFINTLVL_gm ) | intLevel;
   204de:	86 81       	ldd	r24, Z+6	; 0x06
   204e0:	8c 7f       	andi	r24, 0xFC	; 252
   204e2:	86 2b       	or	r24, r22
   204e4:	86 83       	std	Z+6, r24	; 0x06
}
   204e6:	08 95       	ret

000204e8 <TC0_SetErrorIntLevel>:
 *
 *  \param tc               Timer/Counter module instance.
 *  \param intLevel         New error interrupt level.
 */
void TC0_SetErrorIntLevel( volatile TC0_t * tc, TC_ERRINTLVL_t intLevel )
{
   204e8:	fc 01       	movw	r30, r24
	tc->INTCTRLA = ( tc->INTCTRLA & ~TC0_ERRINTLVL_gm ) | intLevel;
   204ea:	86 81       	ldd	r24, Z+6	; 0x06
   204ec:	83 7f       	andi	r24, 0xF3	; 243
   204ee:	86 2b       	or	r24, r22
   204f0:	86 83       	std	Z+6, r24	; 0x06
}
   204f2:	08 95       	ret

000204f4 <TC1_SetErrorIntLevel>:
 *
 *  \param tc               Timer/Counter module instance.
 *  \param intLevel         New error interrupt level.
 */
void TC1_SetErrorIntLevel( volatile TC1_t * tc, TC_ERRINTLVL_t intLevel )
{
   204f4:	fc 01       	movw	r30, r24
	tc->INTCTRLA = ( tc->INTCTRLA & ~TC1_ERRINTLVL_gm ) | intLevel;
   204f6:	86 81       	ldd	r24, Z+6	; 0x06
   204f8:	83 7f       	andi	r24, 0xF3	; 243
   204fa:	86 2b       	or	r24, r22
   204fc:	86 83       	std	Z+6, r24	; 0x06
}
   204fe:	08 95       	ret

00020500 <TC0_SetCCAIntLevel>:
 *
 *  \param tc               Timer/Counter module instance.
 *  \param intLevel         New compare/capture channel A interrupt level.
 */
void TC0_SetCCAIntLevel( volatile TC0_t * tc, TC_CCAINTLVL_t intLevel )
{
   20500:	fc 01       	movw	r30, r24
	tc->INTCTRLB = ( tc->INTCTRLB & ~TC0_CCAINTLVL_gm ) | intLevel;
   20502:	87 81       	ldd	r24, Z+7	; 0x07
   20504:	8c 7f       	andi	r24, 0xFC	; 252
   20506:	86 2b       	or	r24, r22
   20508:	87 83       	std	Z+7, r24	; 0x07
}
   2050a:	08 95       	ret

0002050c <TC1_SetCCAIntLevel>:
 *
 *  \param tc               Timer/Counter module instance.
 *  \param intLevel         New compare/capture channel A interrupt level.
 */
void TC1_SetCCAIntLevel( volatile TC1_t * tc, TC_CCAINTLVL_t intLevel )
{
   2050c:	fc 01       	movw	r30, r24
	tc->INTCTRLB = ( tc->INTCTRLB & ~TC1_CCAINTLVL_gm ) | intLevel;
   2050e:	87 81       	ldd	r24, Z+7	; 0x07
   20510:	8c 7f       	andi	r24, 0xFC	; 252
   20512:	86 2b       	or	r24, r22
   20514:	87 83       	std	Z+7, r24	; 0x07
}
   20516:	08 95       	ret

00020518 <TC0_SetCCBIntLevel>:
 *
 *  \param tc               Timer/Counter module instance.
 *  \param intLevel         New compare/capture channel B interrupt level.
 */
void TC0_SetCCBIntLevel( volatile TC0_t * tc, TC_CCBINTLVL_t intLevel )
{
   20518:	fc 01       	movw	r30, r24
	tc->INTCTRLB = ( tc->INTCTRLB & ~TC0_CCBINTLVL_gm ) | intLevel;
   2051a:	87 81       	ldd	r24, Z+7	; 0x07
   2051c:	83 7f       	andi	r24, 0xF3	; 243
   2051e:	86 2b       	or	r24, r22
   20520:	87 83       	std	Z+7, r24	; 0x07
}
   20522:	08 95       	ret

00020524 <TC1_SetCCBIntLevel>:
 *
 *  \param tc               Timer/Counter module instance.
 *  \param intLevel         New compare/capture channel B interrupt level.
 */
void TC1_SetCCBIntLevel( volatile TC1_t * tc, TC_CCBINTLVL_t intLevel )
{
   20524:	fc 01       	movw	r30, r24
	tc->INTCTRLB = ( tc->INTCTRLB & ~TC1_CCBINTLVL_gm ) | intLevel;
   20526:	87 81       	ldd	r24, Z+7	; 0x07
   20528:	83 7f       	andi	r24, 0xF3	; 243
   2052a:	86 2b       	or	r24, r22
   2052c:	87 83       	std	Z+7, r24	; 0x07
}
   2052e:	08 95       	ret

00020530 <TC0_SetCCCIntLevel>:
 *
 *  \param tc               Timer/Counter module instance.
 *  \param intLevel         New compare/capture channel A interrupt level.
 */
void TC0_SetCCCIntLevel( volatile TC0_t * tc, TC_CCCINTLVL_t intLevel )
{
   20530:	fc 01       	movw	r30, r24
	tc->INTCTRLB = ( tc->INTCTRLB & ~TC0_CCCINTLVL_gm ) | intLevel;
   20532:	87 81       	ldd	r24, Z+7	; 0x07
   20534:	8f 7c       	andi	r24, 0xCF	; 207
   20536:	86 2b       	or	r24, r22
   20538:	87 83       	std	Z+7, r24	; 0x07
}
   2053a:	08 95       	ret

0002053c <TC0_SetCCDIntLevel>:
 *
 *  \param tc               Timer/Counter module instance.
 *  \param intLevel         New compare/capture channel A interrupt level.
 */
void TC0_SetCCDIntLevel( volatile TC0_t * tc, TC_CCDINTLVL_t intLevel )
{
   2053c:	fc 01       	movw	r30, r24
	tc->INTCTRLB = ( tc->INTCTRLB & ~TC0_CCDINTLVL_gm ) | intLevel;
   2053e:	87 81       	ldd	r24, Z+7	; 0x07
   20540:	8f 73       	andi	r24, 0x3F	; 63
   20542:	86 2b       	or	r24, r22
   20544:	87 83       	std	Z+7, r24	; 0x07
}
   20546:	08 95       	ret

00020548 <TC0_Reset>:
 *  reset of the device.
 *
 *  \param tc  Timer/Counter 0 module instance.
 */
void TC0_Reset( volatile TC0_t * tc )
{
   20548:	fc 01       	movw	r30, r24
	/* TC must be turned off before a Reset command. */
	tc->CTRLA = ( tc->CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
   2054a:	80 81       	ld	r24, Z
   2054c:	80 7f       	andi	r24, 0xF0	; 240
   2054e:	80 83       	st	Z, r24

	/* Issue Reset command. */
	tc->CTRLFSET = TC_CMD_RESET_gc;
   20550:	8c e0       	ldi	r24, 0x0C	; 12
   20552:	81 87       	std	Z+9, r24	; 0x09
}
   20554:	08 95       	ret

00020556 <TC1_Reset>:
 *  reset of the device.
 *
 *  \param tc  Timer/Counter 1 module instance.
 */
void TC1_Reset( volatile TC1_t * tc )
{
   20556:	fc 01       	movw	r30, r24
	/* TC must be turned off before a Reset command. */
	tc->CTRLA = ( tc->CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
   20558:	80 81       	ld	r24, Z
   2055a:	80 7f       	andi	r24, 0xF0	; 240
   2055c:	80 83       	st	Z, r24

	/* Issue Reset command. */
	tc->CTRLFSET = TC_CMD_RESET_gc;
   2055e:	8c e0       	ldi	r24, 0x0C	; 12
   20560:	81 87       	std	Z+9, r24	; 0x09
}
   20562:	08 95       	ret

00020564 <quit>:
*/

void quit (void)
{

  CPU_CCP=CCP_IOREG_gc;
   20564:	88 ed       	ldi	r24, 0xD8	; 216
   20566:	84 bf       	out	0x34, r24	; 52
  PMIC.CTRL = 0X00;
   20568:	e0 ea       	ldi	r30, 0xA0	; 160
   2056a:	f0 e0       	ldi	r31, 0x00	; 0
   2056c:	12 82       	std	Z+2, r1	; 0x02
  EIND=0X00;
   2056e:	1c be       	out	0x3c, r1	; 60
  (*((void(*)(void))PROG_START))();
   20570:	e0 e0       	ldi	r30, 0x00	; 0
   20572:	f0 e0       	ldi	r31, 0x00	; 0
   20574:	19 95       	eicall
}
   20576:	08 95       	ret

00020578 <uart_init>:

void uart_init(void)
{
	/* USARTC0 引脚方向设置*/
  	/* PC3 (TXD0) 输出 */
	PORTC.DIRSET   = PIN3_bm;
   20578:	e0 e4       	ldi	r30, 0x40	; 64
   2057a:	f6 e0       	ldi	r31, 0x06	; 6
   2057c:	88 e0       	ldi	r24, 0x08	; 8
   2057e:	81 83       	std	Z+1, r24	; 0x01
	/* PC2 (RXD0) 输入 */
	PORTC.DIRCLR   = PIN2_bm;
   20580:	84 e0       	ldi	r24, 0x04	; 4
   20582:	82 83       	std	Z+2, r24	; 0x02
	/* USARTC0 模式 - 异步*/
	USART_SetMode(&USARTC0,USART_CMODE_ASYNCHRONOUS_gc);
   20584:	e0 ea       	ldi	r30, 0xA0	; 160
   20586:	f8 e0       	ldi	r31, 0x08	; 8
   20588:	85 81       	ldd	r24, Z+5	; 0x05
   2058a:	8f 73       	andi	r24, 0x3F	; 63
   2058c:	85 83       	std	Z+5, r24	; 0x05
	/* USARTC0帧结构, 8 位数据位, 无校验, 1停止位 */
	USART_Format_Set(&USARTC0, USART_CHSIZE_8BIT_gc,USART_PMODE_DISABLED_gc, false);
   2058e:	83 e0       	ldi	r24, 0x03	; 3
   20590:	85 83       	std	Z+5, r24	; 0x05
	/* 设置波特率 9600*/
	USART_Baudrate_Set(&USARTC0, 12 , 0);
   20592:	8c e0       	ldi	r24, 0x0C	; 12
   20594:	86 83       	std	Z+6, r24	; 0x06
   20596:	17 82       	std	Z+7, r1	; 0x07
	/* USARTC0 使能发送*/
	USART_Tx_Enable(&USARTC0);
   20598:	84 81       	ldd	r24, Z+4	; 0x04
   2059a:	88 60       	ori	r24, 0x08	; 8
   2059c:	84 83       	std	Z+4, r24	; 0x04
	/* USARTC0 使能接收*/
	USART_Rx_Enable(&USARTC0);
   2059e:	84 81       	ldd	r24, Z+4	; 0x04
   205a0:	80 61       	ori	r24, 0x10	; 16
   205a2:	84 83       	std	Z+4, r24	; 0x04
}
   205a4:	08 95       	ret

000205a6 <main>:
| Description : 初始化 USARTC0
+------------------------------------------------------------------------------
*/
void main( void )
{   
    uart_init();
   205a6:	0f 94 bc 02 	call	0x20578	; 0x20578 <uart_init>
    uart_puts((void *)"enter into main");
   205aa:	80 e0       	ldi	r24, 0x00	; 0
   205ac:	90 e2       	ldi	r25, 0x20	; 32
   205ae:	0f 94 11 02 	call	0x20422	; 0x20422 <uart_puts>
	uart_putc('\n');
   205b2:	8a e0       	ldi	r24, 0x0A	; 10
   205b4:	0f 94 22 01 	call	0x20244	; 0x20244 <uart_putc>
	bootapp=true;
   205b8:	81 e0       	ldi	r24, 0x01	; 1
   205ba:	80 93 10 20 	sts	0x2010, r24
    TC_SetPeriod( &TCC0, 0x1000 );
   205be:	80 e0       	ldi	r24, 0x00	; 0
   205c0:	90 e1       	ldi	r25, 0x10	; 16
   205c2:	e0 e0       	ldi	r30, 0x00	; 0
   205c4:	f8 e0       	ldi	r31, 0x08	; 8
   205c6:	86 a3       	std	Z+38, r24	; 0x26
   205c8:	97 a3       	std	Z+39, r25	; 0x27
 *  \param tc              Timer/Counter module instance.
 *  \param clockSelection  Timer/Counter clock source setting.
 */
void TC0_ConfigClockSource( volatile TC0_t * tc, TC_CLKSEL_t clockSelection )
{
	tc->CTRLA = ( tc->CTRLA & ~TC0_CLKSEL_gm ) | clockSelection;
   205ca:	80 91 00 08 	lds	r24, 0x0800
   205ce:	80 7f       	andi	r24, 0xF0	; 240
   205d0:	87 60       	ori	r24, 0x07	; 7
   205d2:	80 93 00 08 	sts	0x0800, r24
	TC0_ConfigClockSource( &TCC0, TC_CLKSEL_DIV1024_gc );
    USART_RxdInterruptLevel_Set(&USARTC0,USART_RXCINTLVL_LO_gc);
   205d6:	80 91 a3 08 	lds	r24, 0x08A3
   205da:	8f 7c       	andi	r24, 0xCF	; 207
   205dc:	80 61       	ori	r24, 0x10	; 16
   205de:	e0 ea       	ldi	r30, 0xA0	; 160
   205e0:	f8 e0       	ldi	r31, 0x08	; 8
   205e2:	83 83       	std	Z+3, r24	; 0x03
	/*使能中断*/
	CPU_CCP=CCP_IOREG_gc;
   205e4:	88 ed       	ldi	r24, 0xD8	; 216
   205e6:	84 bf       	out	0x34, r24	; 52
	PMIC.CTRL = PMIC_LOLVLEN_bm|PMIC_IVSEL_bm; //Enable Low_Level interrupts
   205e8:	81 e4       	ldi	r24, 0x41	; 65
   205ea:	e0 ea       	ldi	r30, 0xA0	; 160
   205ec:	f0 e0       	ldi	r31, 0x00	; 0
   205ee:	82 83       	std	Z+2, r24	; 0x02
	sei();	
   205f0:	78 94       	sei
	while(bootapp);
   205f2:	80 91 10 20 	lds	r24, 0x2010
   205f6:	88 23       	and	r24, r24
   205f8:	e1 f7       	brne	.-8      	; 0x205f2 <main+0x4c>
	cli();
   205fa:	f8 94       	cli
	quit();
   205fc:	0f 94 b2 02 	call	0x20564	; 0x20564 <quit>
	 
}
   20600:	08 95       	ret

00020602 <write_one_page>:
+------------------------------------------------------------------------------
*/
 //更新一个Flash页
void write_one_page(unsigned char *buf)
{
    FlashAddr=0x5000;
   20602:	20 e0       	ldi	r18, 0x00	; 0
   20604:	30 e5       	ldi	r19, 0x50	; 80
   20606:	40 e0       	ldi	r20, 0x00	; 0
   20608:	50 e0       	ldi	r21, 0x00	; 0
   2060a:	20 93 0f 22 	sts	0x220F, r18
   2060e:	30 93 10 22 	sts	0x2210, r19
   20612:	40 93 11 22 	sts	0x2211, r20
   20616:	50 93 12 22 	sts	0x2212, r21
    //数据填入Flash缓冲页
	SP_LoadFlashPage(buf);
   2061a:	0f 94 fc 03 	call	0x207f8	; 0x207f8 <SP_LoadFlashPage>
	//将缓冲页数据写入一个Flash页
	SP_EraseWriteApplicationPage(FlashAddr);
   2061e:	60 91 0f 22 	lds	r22, 0x220F
   20622:	70 91 10 22 	lds	r23, 0x2210
   20626:	80 91 11 22 	lds	r24, 0x2211
   2062a:	90 91 12 22 	lds	r25, 0x2212
   2062e:	0f 94 26 04 	call	0x2084c	; 0x2084c <SP_EraseWriteApplicationPage>
	/* Wait for NVM to finish. */
	SP_WaitForSPM();//等待页编程完成                      
   20632:	0f 94 4d 04 	call	0x2089a	; 0x2089a <SP_WaitForSPM>
}
   20636:	08 95       	ret

00020638 <__vector_25>:
+------------------------------------------------------------------------------
| Description : USARTC0接收中断函数 收到的数据发送回去USARTC0
+------------------------------------------------------------------------------
*/
ISR(USARTC0_RXC_vect) 
{    
   20638:	1f 92       	push	r1
   2063a:	0f 92       	push	r0
   2063c:	0f b6       	in	r0, 0x3f	; 63
   2063e:	0f 92       	push	r0
   20640:	08 b6       	in	r0, 0x38	; 56
   20642:	0f 92       	push	r0
   20644:	09 b6       	in	r0, 0x39	; 57
   20646:	0f 92       	push	r0
   20648:	0b b6       	in	r0, 0x3b	; 59
   2064a:	0f 92       	push	r0
   2064c:	11 24       	eor	r1, r1
   2064e:	18 be       	out	0x38, r1	; 56
   20650:	19 be       	out	0x39, r1	; 57
   20652:	1b be       	out	0x3b, r1	; 59
   20654:	0f 93       	push	r16
   20656:	1f 93       	push	r17
   20658:	2f 93       	push	r18
   2065a:	3f 93       	push	r19
   2065c:	4f 93       	push	r20
   2065e:	5f 93       	push	r21
   20660:	6f 93       	push	r22
   20662:	7f 93       	push	r23
   20664:	8f 93       	push	r24
   20666:	9f 93       	push	r25
   20668:	af 93       	push	r26
   2066a:	bf 93       	push	r27
   2066c:	ef 93       	push	r30
   2066e:	ff 93       	push	r31
       
       uint8_t count_num=0;
	   bootapp=false;
   20670:	10 92 10 20 	sts	0x2010, r1
	   TCC0_CNT=0;
   20674:	10 92 20 08 	sts	0x0820, r1
   20678:	10 92 21 08 	sts	0x0821, r1
	   receivedata[count_num]= USART_GetChar(&USARTC0);//读Data Register
   2067c:	80 91 a0 08 	lds	r24, 0x08A0
   20680:	80 93 11 20 	sts	0x2011, r24
   20684:	10 92 12 20 	sts	0x2012, r1
   20688:	00 e0       	ldi	r16, 0x00	; 0
   2068a:	13 c0       	rjmp	.+38     	; 0x206b2 <__vector_25+0x7a>
      

	   //接收间隔大于20，接收结束
       while(TCC0_CNT<=20)
	  {
		if((USARTC0.STATUS&0x80)==0x80)
   2068c:	80 91 a1 08 	lds	r24, 0x08A1
   20690:	87 ff       	sbrs	r24, 7
   20692:	0f c0       	rjmp	.+30     	; 0x206b2 <__vector_25+0x7a>
	  	{
		count_num++;
   20694:	0f 5f       	subi	r16, 0xFF	; 255
        receivedata[count_num]= USART_GetChar(&USARTC0);//读Data Register
   20696:	80 91 a0 08 	lds	r24, 0x08A0
   2069a:	e0 2f       	mov	r30, r16
   2069c:	f0 e0       	ldi	r31, 0x00	; 0
   2069e:	ee 0f       	add	r30, r30
   206a0:	ff 1f       	adc	r31, r31
   206a2:	ef 5e       	subi	r30, 0xEF	; 239
   206a4:	ff 4d       	sbci	r31, 0xDF	; 223
   206a6:	80 83       	st	Z, r24
   206a8:	11 82       	std	Z+1, r1	; 0x01
	    TCC0_CNT=0;
   206aa:	10 92 20 08 	sts	0x0820, r1
   206ae:	10 92 21 08 	sts	0x0821, r1
	   TCC0_CNT=0;
	   receivedata[count_num]= USART_GetChar(&USARTC0);//读Data Register
      

	   //接收间隔大于20，接收结束
       while(TCC0_CNT<=20)
   206b2:	80 91 20 08 	lds	r24, 0x0820
   206b6:	90 91 21 08 	lds	r25, 0x0821
   206ba:	45 97       	sbiw	r24, 0x15	; 21
   206bc:	38 f3       	brcs	.-50     	; 0x2068c <__vector_25+0x54>
	    TCC0_CNT=0;
		 
		} 

	  }		  
	  write_one_page(receivedata); 
   206be:	81 e1       	ldi	r24, 0x11	; 17
   206c0:	90 e2       	ldi	r25, 0x20	; 32
   206c2:	0f 94 01 03 	call	0x20602	; 0x20602 <write_one_page>
	  FlashAddr=0x5000;
   206c6:	80 e0       	ldi	r24, 0x00	; 0
   206c8:	90 e5       	ldi	r25, 0x50	; 80
   206ca:	a0 e0       	ldi	r26, 0x00	; 0
   206cc:	b0 e0       	ldi	r27, 0x00	; 0
   206ce:	80 93 0f 22 	sts	0x220F, r24
   206d2:	90 93 10 22 	sts	0x2210, r25
   206d6:	a0 93 11 22 	sts	0x2211, r26
   206da:	b0 93 12 22 	sts	0x2212, r27
   206de:	10 e0       	ldi	r17, 0x00	; 0
	  for(uint8_t i=0;i<=count_num;i++)
	  {
	  readdata[i]=SP_ReadWord(FlashAddr);
   206e0:	60 91 0f 22 	lds	r22, 0x220F
   206e4:	70 91 10 22 	lds	r23, 0x2210
   206e8:	80 91 11 22 	lds	r24, 0x2211
   206ec:	90 91 12 22 	lds	r25, 0x2212
   206f0:	0f 94 c8 03 	call	0x20790	; 0x20790 <SP_ReadWord>
   206f4:	e1 2f       	mov	r30, r17
   206f6:	f0 e0       	ldi	r31, 0x00	; 0
   206f8:	ee 0f       	add	r30, r30
   206fa:	ff 1f       	adc	r31, r31
   206fc:	ed 5e       	subi	r30, 0xED	; 237
   206fe:	fd 4d       	sbci	r31, 0xDD	; 221
   20700:	80 83       	st	Z, r24
   20702:	91 83       	std	Z+1, r25	; 0x01
      FlashAddr++;
	  FlashAddr++;
   20704:	80 91 0f 22 	lds	r24, 0x220F
   20708:	90 91 10 22 	lds	r25, 0x2210
   2070c:	a0 91 11 22 	lds	r26, 0x2211
   20710:	b0 91 12 22 	lds	r27, 0x2212
   20714:	02 96       	adiw	r24, 0x02	; 2
   20716:	a1 1d       	adc	r26, r1
   20718:	b1 1d       	adc	r27, r1
   2071a:	80 93 0f 22 	sts	0x220F, r24
   2071e:	90 93 10 22 	sts	0x2210, r25
   20722:	a0 93 11 22 	sts	0x2211, r26
   20726:	b0 93 12 22 	sts	0x2212, r27
		} 

	  }		  
	  write_one_page(receivedata); 
	  FlashAddr=0x5000;
	  for(uint8_t i=0;i<=count_num;i++)
   2072a:	1f 5f       	subi	r17, 0xFF	; 255
   2072c:	01 17       	cp	r16, r17
   2072e:	c0 f6       	brcc	.-80     	; 0x206e0 <__vector_25+0xa8>
   20730:	90 e0       	ldi	r25, 0x00	; 0
	  FlashAddr++;
	  }
	  
      for(uint8_t i=0;i<=count_num;i++)
	  {
        while(!USART_IsTXDataRegisterEmpty(&USARTC0));
   20732:	80 91 a1 08 	lds	r24, 0x08A1
   20736:	85 ff       	sbrs	r24, 5
   20738:	fc cf       	rjmp	.-8      	; 0x20732 <__vector_25+0xfa>
        USART_PutChar(&USARTC0,readdata[i]);
   2073a:	e9 2f       	mov	r30, r25
   2073c:	f0 e0       	ldi	r31, 0x00	; 0
   2073e:	ee 0f       	add	r30, r30
   20740:	ff 1f       	adc	r31, r31
   20742:	ed 5e       	subi	r30, 0xED	; 237
   20744:	fd 4d       	sbci	r31, 0xDD	; 221
   20746:	80 81       	ld	r24, Z
   20748:	80 93 a0 08 	sts	0x08A0, r24
	  readdata[i]=SP_ReadWord(FlashAddr);
      FlashAddr++;
	  FlashAddr++;
	  }
	  
      for(uint8_t i=0;i<=count_num;i++)
   2074c:	9f 5f       	subi	r25, 0xFF	; 255
   2074e:	09 17       	cp	r16, r25
   20750:	80 f7       	brcc	.-32     	; 0x20732 <__vector_25+0xfa>
	  {
        while(!USART_IsTXDataRegisterEmpty(&USARTC0));
        USART_PutChar(&USARTC0,readdata[i]);
      } 	  
}
   20752:	ff 91       	pop	r31
   20754:	ef 91       	pop	r30
   20756:	bf 91       	pop	r27
   20758:	af 91       	pop	r26
   2075a:	9f 91       	pop	r25
   2075c:	8f 91       	pop	r24
   2075e:	7f 91       	pop	r23
   20760:	6f 91       	pop	r22
   20762:	5f 91       	pop	r21
   20764:	4f 91       	pop	r20
   20766:	3f 91       	pop	r19
   20768:	2f 91       	pop	r18
   2076a:	1f 91       	pop	r17
   2076c:	0f 91       	pop	r16
   2076e:	0f 90       	pop	r0
   20770:	0b be       	out	0x3b, r0	; 59
   20772:	0f 90       	pop	r0
   20774:	09 be       	out	0x39, r0	; 57
   20776:	0f 90       	pop	r0
   20778:	08 be       	out	0x38, r0	; 56
   2077a:	0f 90       	pop	r0
   2077c:	0f be       	out	0x3f, r0	; 63
   2077e:	0f 90       	pop	r0
   20780:	1f 90       	pop	r1
   20782:	18 95       	reti

00020784 <SP_ReadByte>:

.section .text
.global SP_ReadByte

SP_ReadByte:
	in	r19, RAMPZ      ; Save RAMPZ.
   20784:	3b b7       	in	r19, 0x3b	; 59
	out	RAMPZ, r24      ; Load RAMPZ with the MSB of the address.
   20786:	8b bf       	out	0x3b, r24	; 59
	movw	ZL, r22         ; Move the low bytes to the Z pointer
   20788:	fb 01       	movw	r30, r22
	elpm	r24, Z          ; Extended load byte from address pointed to by Z.
   2078a:	86 91       	elpm	r24, Z+
	out	RAMPZ, r19      ; Restore RAMPZ register.
   2078c:	3b bf       	out	0x3b, r19	; 59
	ret
   2078e:	08 95       	ret

00020790 <SP_ReadWord>:

.section .text
.global SP_ReadWord

SP_ReadWord:
	in	r19, RAMPZ      ; Save RAMPZ.
   20790:	3b b7       	in	r19, 0x3b	; 59
	out	RAMPZ, r24      ; Load RAMPZ with the MSB of the address.
   20792:	8b bf       	out	0x3b, r24	; 59
	movw	ZL, r22         ; Move the low bytes to the Z pointer
   20794:	fb 01       	movw	r30, r22
	elpm	r24, Z+         ; Extended load byte from address pointed to by Z.
   20796:	87 91       	elpm	r24, Z+
	elpm	r25, Z          ; Extended load byte from address pointed to by Z.
   20798:	96 91       	elpm	r25, Z+
	out	RAMPZ, r19      ; Restore RAMPZ register.
   2079a:	3b bf       	out	0x3b, r19	; 59
	ret
   2079c:	08 95       	ret

0002079e <SP_ReadCalibrationByte>:

.section .text
.global SP_ReadCalibrationByte	

SP_ReadCalibrationByte:
	ldi	r20, NVM_CMD_READ_CALIB_ROW_gc    ; Prepare NVM command in R20.
   2079e:	42 e0       	ldi	r20, 0x02	; 2
	rjmp	SP_CommonLPM                      ; Jump to common LPM code.
   207a0:	94 c0       	rjmp	.+296    	; 0x208ca <SP_CommonLPM>

000207a2 <SP_ReadUserSignatureByte>:

.section .text	
.global SP_ReadUserSignatureByte

SP_ReadUserSignatureByte:
	ldi	r20, NVM_CMD_READ_USER_SIG_ROW_gc  ; Prepare NVM command in R20.
   207a2:	41 e0       	ldi	r20, 0x01	; 1
	rjmp	SP_CommonLPM                       ; Jump to common LPM code.
   207a4:	92 c0       	rjmp	.+292    	; 0x208ca <SP_CommonLPM>

000207a6 <SP_ReadFuseByte>:

.section .text	
.global SP_ReadFuseByte

SP_ReadFuseByte:
	sts	NVM_ADDR0, r24              ; Load fuse byte index into NVM Address Register 0.
   207a6:	80 93 c0 01 	sts	0x01C0, r24
	clr	r24                         ; Prepare a zero.
   207aa:	88 27       	eor	r24, r24
	sts	NVM_ADDR1, r24              ; Load zero into NVM Address Register 1.
   207ac:	80 93 c1 01 	sts	0x01C1, r24
	sts	NVM_ADDR2, r24              ; Load zero into NVM Address Register 2.
   207b0:	80 93 c2 01 	sts	0x01C2, r24
	ldi	r20, NVM_CMD_READ_FUSES_gc  ; Prepare NVM command in R20.
   207b4:	47 e0       	ldi	r20, 0x07	; 7
	rcall	SP_CommonCMD                ; Jump to common NVM Action code.
   207b6:	79 d0       	rcall	.+242    	; 0x208aa <SP_CommonCMD>
	movw	r24, r22                    ; Move low byte to 1 byte return address.
   207b8:	cb 01       	movw	r24, r22
	ret
   207ba:	08 95       	ret

000207bc <SP_WriteLockBits>:

.section .text	
.global SP_WriteLockBits

SP_WriteLockBits:
	sts	NVM_DATA0, r24                  ; Load lock bits into NVM Data Register 0.
   207bc:	80 93 c4 01 	sts	0x01C4, r24
	ldi	r20, NVM_CMD_WRITE_LOCK_BITS_gc ; Prepare NVM command in R20.
   207c0:	48 e0       	ldi	r20, 0x08	; 8
	rjmp	SP_CommonCMD                    ; Jump to common NVM Action code.
   207c2:	73 c0       	rjmp	.+230    	; 0x208aa <SP_CommonCMD>

000207c4 <SP_ReadLockBits>:

.section .text		
.global SP_ReadLockBits

SP_ReadLockBits:
	lds	r24, NVM_LOCKBITS       ; Read IO-mapped lock bits.
   207c4:	80 91 d0 01 	lds	r24, 0x01D0
	ret
   207c8:	08 95       	ret

000207ca <SP_EraseUserSignatureRow>:

.section .text
.global SP_EraseUserSignatureRow

SP_EraseUserSignatureRow:
	in	r19, RAMPZ                         ; Save RAMPZ, which is restored in SP_CommonSPM.
   207ca:	3b b7       	in	r19, 0x3b	; 59
	ldi	r20, NVM_CMD_ERASE_USER_SIG_ROW_gc ; Prepare NVM command in R20.
   207cc:	48 e1       	ldi	r20, 0x18	; 24
	jmp 	SP_CommonSPM                       ; Jump to common SPM code.
   207ce:	0d 94 6a 04 	jmp	0x208d4	; 0x208d4 <SP_CommonSPM>

000207d2 <SP_WriteUserSignatureRow>:

.section .text
.global SP_WriteUserSignatureRow

SP_WriteUserSignatureRow:
	in	r19, RAMPZ                          ; Save RAMPZ, which is restored in SP_CommonSPM.
   207d2:	3b b7       	in	r19, 0x3b	; 59
	ldi	r20, NVM_CMD_WRITE_USER_SIG_ROW_gc  ; Prepare NVM command in R20.
   207d4:	4a e1       	ldi	r20, 0x1A	; 26
	jmp	SP_CommonSPM                        ; Jump to common SPM code.
   207d6:	0d 94 6a 04 	jmp	0x208d4	; 0x208d4 <SP_CommonSPM>

000207da <SP_EraseApplicationSection>:

.section .text
.global SP_EraseApplicationSection

SP_EraseApplicationSection:
	in	r19, RAMPZ                 ; Save RAMPZ, which is restored in SP_CommonSPM.
   207da:	3b b7       	in	r19, 0x3b	; 59
	ldi	r20, NVM_CMD_ERASE_APP_gc  ; Prepare NVM command in R20.
   207dc:	40 e2       	ldi	r20, 0x20	; 32
	jmp	SP_CommonSPM               ; Jump to common SPM code.
   207de:	0d 94 6a 04 	jmp	0x208d4	; 0x208d4 <SP_CommonSPM>

000207e2 <SP_EraseApplicationPage>:

.section .text	
.global SP_EraseApplicationPage

SP_EraseApplicationPage:
	in	r19, RAMPZ                      ; Save RAMPZ, which is restored in SP_CommonSPM.
   207e2:	3b b7       	in	r19, 0x3b	; 59
	out	RAMPZ, r24                      ; Load RAMPZ with the MSB of the address.
   207e4:	8b bf       	out	0x3b, r24	; 59
	movw    r24, r22                        ; Move low bytes for ZH:ZL to R25:R24
   207e6:	cb 01       	movw	r24, r22
	ldi	r20, NVM_CMD_ERASE_APP_PAGE_gc  ; Prepare NVM command in R20.
   207e8:	42 e2       	ldi	r20, 0x22	; 34
	jmp	SP_CommonSPM                    ; Jump to common SPM code.
   207ea:	0d 94 6a 04 	jmp	0x208d4	; 0x208d4 <SP_CommonSPM>

000207ee <SP_LoadFlashWord>:

.section .text
.global SP_LoadFlashWord

SP_LoadFlashWord:
	in	r19, RAMPZ                         ; Save RAMPZ, which is restored in SP_CommonSPM.
   207ee:	3b b7       	in	r19, 0x3b	; 59
	movw	r0, r22                            ; Prepare flash word in R1:R0.
   207f0:	0b 01       	movw	r0, r22
	ldi	r20, NVM_CMD_LOAD_FLASH_BUFFER_gc  ; Prepare NVM command in R20.
   207f2:	43 e2       	ldi	r20, 0x23	; 35
	jmp	SP_CommonSPM                       ; Jump to common SPM code.
   207f4:	0d 94 6a 04 	jmp	0x208d4	; 0x208d4 <SP_CommonSPM>

000207f8 <SP_LoadFlashPage>:
		
.section .text, "ax"
.global SP_LoadFlashPage

SP_LoadFlashPage:
	clr	ZL              ; Clear low byte of Z, to indicate start of page.
   207f8:	ee 27       	eor	r30, r30
	clr	ZH              ; Clear high byte of Z, to indicate start of page.
   207fa:	ff 27       	eor	r31, r31

	out	RAMPX, r1       ; Clear RAMPX pointer.
   207fc:	19 be       	out	0x39, r1	; 57
	movw	XL, r24         ; Load X with data buffer address.
   207fe:	dc 01       	movw	r26, r24

	ldi 	r20, NVM_CMD_LOAD_FLASH_BUFFER_gc  ; Prepare NVM command code in R20.
   20800:	43 e2       	ldi	r20, 0x23	; 35
	sts	NVM_CMD, r20                       ; Load it into NVM command register.
   20802:	40 93 ca 01 	sts	0x01CA, r20

#if FLASH_PAGE_SIZE > 512
	ldi	r22, ((FLASH_PAGE_SIZE/2) >> 8)
#endif

	ldi	r21, ((FLASH_PAGE_SIZE/2)&0xFF)    ; Load R21 with page word count.
   20806:	50 e0       	ldi	r21, 0x00	; 0
	ldi	r18, CCP_SPM_gc                    ; Prepare Protect SPM signature in R16.
   20808:	2d e9       	ldi	r18, 0x9D	; 157

0002080a <SP_LoadFlashPage_1>:

SP_LoadFlashPage_1:
	ld	r0, X+         ; Load low byte from buffer into R0.
   2080a:	0d 90       	ld	r0, X+
	ld	r1, X+         ; Load high byte from buffer into R1.
   2080c:	1d 90       	ld	r1, X+
	sts	CCP, r18       ; Enable SPM operation (this disables interrupts for 4 cycles).
   2080e:	20 93 34 00 	sts	0x0034, r18
	spm                    ; Self-program.
   20812:	e8 95       	spm
	adiw	ZL, 2          ; Move Z to next Flash word.
   20814:	32 96       	adiw	r30, 0x02	; 2

#if FLASH_PAGE_SIZE > 512
	subi	r21, 1         ; Decrement word count.
	sbci	r22, 0
#else
	dec	r21            ; Decrement word count.
   20816:	5a 95       	dec	r21
#endif

	brne	SP_LoadFlashPage_1   ; Repeat until word cont is zero.
   20818:	c1 f7       	brne	.-16     	; 0x2080a <SP_LoadFlashPage_1>

	clr	r1                   ; Clear R1 for GCC _zero_reg_ to function properly.
   2081a:	11 24       	eor	r1, r1
	ret
   2081c:	08 95       	ret

0002081e <SP_ReadFlashPage>:
.section .text		
.global SP_ReadFlashPage

SP_ReadFlashPage:

	in	r19, RAMPZ                   ; Save RAMPZ during assembly.
   2081e:	3b b7       	in	r19, 0x3b	; 59
	out	RAMPZ, r22                   ; Load RAMPZ with MSB of address
   20820:	6b bf       	out	0x3b, r22	; 59
	movw    ZL, r20                      ; Load Z with Flash address.
   20822:	fa 01       	movw	r30, r20

	out	RAMPX, r1                    ; Load RAMPX with data pointer
   20824:	19 be       	out	0x39, r1	; 57
	movw	XL, r24                      ; Load X with data buffer address.
   20826:	dc 01       	movw	r26, r24

	ldi	r20, NVM_CMD_NO_OPERATION_gc ; Prepare NVM command code in R20.
   20828:	40 e0       	ldi	r20, 0x00	; 0
	sts	NVM_CMD, r20                 ; Set NVM command to No Operation so that LPM reads Flash.
   2082a:	40 93 ca 01 	sts	0x01CA, r20

#if FLASH_PAGE_SIZE > 512
	ldi	r22, ((FLASH_PAGE_SIZE/2) >> 8) ; Load R22 with byte cont high if flash page is large.
#endif	

	ldi	r21, ((FLASH_PAGE_SIZE)&0xFF)   ; Load R21 with byte count.
   2082e:	50 e0       	ldi	r21, 0x00	; 0

00020830 <SP_ReadFlashPage_1>:

SP_ReadFlashPage_1:
	elpm	r24, Z+                         ; Load Flash bytes into R18:r19
   20830:	87 91       	elpm	r24, Z+
	elpm	r25, Z+
   20832:	97 91       	elpm	r25, Z+
	st	X+, r24                         ; Write bytes to buffer.
   20834:	8d 93       	st	X+, r24
	st	X+, r25
   20836:	9d 93       	st	X+, r25

#if FLASH_PAGE_SIZE > 512
	subi	r21, 1                          ; Decrement word count.
	sbci	r22, 0
#else
	dec	r21                             ; Decrement word count.
   20838:	5a 95       	dec	r21
#endif	

	brne	SP_ReadFlashPage_1              ; Repeat until byte count is zero.
   2083a:	d1 f7       	brne	.-12     	; 0x20830 <SP_ReadFlashPage_1>

	out	RAMPZ, r19
   2083c:	3b bf       	out	0x3b, r19	; 59
	ret
   2083e:	08 95       	ret

00020840 <SP_WriteApplicationPage>:

.section .text		
.global SP_WriteApplicationPage

SP_WriteApplicationPage:
	in	r19, RAMPZ                       ; Save RAMPZ, which is restored in SP_CommonSPM.
   20840:	3b b7       	in	r19, 0x3b	; 59
	out	RAMPZ, r24                       ; Load RAMPZ with the MSB of the address.
   20842:	8b bf       	out	0x3b, r24	; 59
	movw	r24, r22                         ; Move low bytes of address to ZH:ZL from R23:R22
   20844:	cb 01       	movw	r24, r22
	ldi	r20, NVM_CMD_WRITE_APP_PAGE_gc   ; Prepare NVM command in R20.
   20846:	44 e2       	ldi	r20, 0x24	; 36
	jmp	SP_CommonSPM                     ; Jump to common SPM code.
   20848:	0d 94 6a 04 	jmp	0x208d4	; 0x208d4 <SP_CommonSPM>

0002084c <SP_EraseWriteApplicationPage>:
; ---
.section .text
.global SP_EraseWriteApplicationPage

SP_EraseWriteApplicationPage:
	in	r19, RAMPZ                            ; Save RAMPZ, which is restored in SP_CommonSPM.
   2084c:	3b b7       	in	r19, 0x3b	; 59
	out	RAMPZ, r24                            ; Load RAMPZ with the MSB of the address.
   2084e:	8b bf       	out	0x3b, r24	; 59
	movw	r24, r22                              ; Move low bytes of address to ZH:ZL from R23:R22
   20850:	cb 01       	movw	r24, r22
	ldi	r20, NVM_CMD_ERASE_WRITE_APP_PAGE_gc  ; Prepare NVM command in R20.
   20852:	45 e2       	ldi	r20, 0x25	; 37
	jmp	SP_CommonSPM                          ; Jump to common SPM code.
   20854:	0d 94 6a 04 	jmp	0x208d4	; 0x208d4 <SP_CommonSPM>

00020858 <SP_EraseFlashBuffer>:

.section .text		
.global SP_EraseFlashBuffer

SP_EraseFlashBuffer:
	in	r19, RAMPZ                          ; Save RAMPZ, which is restored in SP_CommonSPM.
   20858:	3b b7       	in	r19, 0x3b	; 59
	ldi	r20, NVM_CMD_ERASE_FLASH_BUFFER_gc  ; Prepare NVM command in R20.
   2085a:	46 e2       	ldi	r20, 0x26	; 38
	jmp	SP_CommonSPM                        ; Jump to common SPM code.
   2085c:	0d 94 6a 04 	jmp	0x208d4	; 0x208d4 <SP_CommonSPM>

00020860 <SP_EraseBootPage>:

.section .text		
.global SP_EraseBootPage

SP_EraseBootPage:
	in	r19, RAMPZ                         ; Save RAMPZ, which is restored in SP_CommonSPM.
   20860:	3b b7       	in	r19, 0x3b	; 59
	out	RAMPZ, r24                         ; Load RAMPZ with the MSB of the address.
   20862:	8b bf       	out	0x3b, r24	; 59
	movw	r24, r22                           ; Move low bytes of address to ZH:ZL from R23:R22
   20864:	cb 01       	movw	r24, r22
	ldi	r20, NVM_CMD_ERASE_BOOT_PAGE_gc    ; Prepare NVM command in R20.
   20866:	4a e2       	ldi	r20, 0x2A	; 42
	jmp	SP_CommonSPM                       ; Jump to common SPM code.
   20868:	0d 94 6a 04 	jmp	0x208d4	; 0x208d4 <SP_CommonSPM>

0002086c <SP_WriteBootPage>:

.section .text		
.global SP_WriteBootPage

SP_WriteBootPage:
	in	r19, RAMPZ                       ; Save RAMPZ, which is restored in SP_CommonSPM.
   2086c:	3b b7       	in	r19, 0x3b	; 59
	out	RAMPZ, r24                       ; Load RAMPZ with the MSB of the address.
   2086e:	8b bf       	out	0x3b, r24	; 59
	movw	r24, r22                         ; Move low bytes of address to ZH:ZL from R23:R22
   20870:	cb 01       	movw	r24, r22
	ldi	r20, NVM_CMD_WRITE_BOOT_PAGE_gc  ; Prepare NVM command in R20.
   20872:	4c e2       	ldi	r20, 0x2C	; 44
	jmp	SP_CommonSPM                     ; Jump to common SPM code.
   20874:	0d 94 6a 04 	jmp	0x208d4	; 0x208d4 <SP_CommonSPM>

00020878 <SP_EraseWriteBootPage>:

.section .text		
.global SP_EraseWriteBootPage

SP_EraseWriteBootPage:
	in	r19, RAMPZ                             ; Save RAMPZ, which is restored in SP_CommonSPM.
   20878:	3b b7       	in	r19, 0x3b	; 59
	out	RAMPZ, r24                             ; Load RAMPZ with the MSB of the address.
   2087a:	8b bf       	out	0x3b, r24	; 59
	movw	r24, r22                               ; Move low bytes of address to ZH:ZL from R23:R22
   2087c:	cb 01       	movw	r24, r22
	ldi	r20, NVM_CMD_ERASE_WRITE_BOOT_PAGE_gc  ; Prepare NVM command in R20.
   2087e:	4d e2       	ldi	r20, 0x2D	; 45
	jmp	SP_CommonSPM                           ; Jump to common SPM code.
   20880:	0d 94 6a 04 	jmp	0x208d4	; 0x208d4 <SP_CommonSPM>

00020884 <SP_ApplicationCRC>:

.section .text	
.global SP_ApplicationCRC

SP_ApplicationCRC:
	ldi	r20, NVM_CMD_APP_CRC_gc    ; Prepare NVM command in R20.
   20884:	48 e3       	ldi	r20, 0x38	; 56
	rjmp	SP_CommonCMD               ; Jump to common NVM Action code.
   20886:	11 c0       	rjmp	.+34     	; 0x208aa <SP_CommonCMD>

00020888 <SP_BootCRC>:

.section .text
.global SP_BootCRC

SP_BootCRC:
	ldi	r20, NVM_CMD_BOOT_CRC_gc   ; Prepare NVM command in R20.
   20888:	49 e3       	ldi	r20, 0x39	; 57
	rjmp	SP_CommonCMD               ; Jump to common NVM Action code.
   2088a:	0f c0       	rjmp	.+30     	; 0x208aa <SP_CommonCMD>

0002088c <SP_LockSPM>:

.section .text
.global SP_LockSPM

SP_LockSPM:
	ldi	r18, CCP_IOREG_gc     ; Prepare Protect IO-register signature in R18.
   2088c:	28 ed       	ldi	r18, 0xD8	; 216
	sts	CCP, r18              ; Enable IO-register operation (this disables interrupts for 4 cycles).
   2088e:	20 93 34 00 	sts	0x0034, r18
	ldi	r18, NVM_SPMLOCK_bm   ; Prepare bitmask for locking SPM into R18.
   20892:	21 e0       	ldi	r18, 0x01	; 1
	sts	NVM_CTRLB, r18        ; Load bitmask into NVM Control Register B, which locks SPM.
   20894:	20 93 cc 01 	sts	0x01CC, r18
	ret
   20898:	08 95       	ret

0002089a <SP_WaitForSPM>:

.section .text
.global SP_WaitForSPM		

SP_WaitForSPM:
	lds	r18, NVM_STATUS     ; Load the NVM Status register.
   2089a:	20 91 cf 01 	lds	r18, 0x01CF
	sbrc	r18, NVM_NVMBUSY_bp ; Check if bit is cleared.
   2089e:	27 fd       	sbrc	r18, 7
	rjmp	SP_WaitForSPM       ; Repeat check if bit is not cleared.
   208a0:	fc cf       	rjmp	.-8      	; 0x2089a <SP_WaitForSPM>
	clr	r18
   208a2:	22 27       	eor	r18, r18
	sts	NVM_CMD, r18        ; Clear up command register to NO_OPERATION.
   208a4:	20 93 ca 01 	sts	0x01CA, r18
	ret
   208a8:	08 95       	ret

000208aa <SP_CommonCMD>:
; ---

.section .text		

SP_CommonCMD:
	sts	NVM_CMD, r20        ; Load command into NVM Command register.
   208aa:	40 93 ca 01 	sts	0x01CA, r20
	ldi	r18, CCP_IOREG_gc   ; Prepare Protect IO-register signature in R18.
   208ae:	28 ed       	ldi	r18, 0xD8	; 216
	ldi	r19, NVM_CMDEX_bm   ; Prepare bitmask for setting NVM Command Execute bit into R19.
   208b0:	31 e0       	ldi	r19, 0x01	; 1
	sts	CCP, r18            ; Enable IO-register operation (this disables interrupts for 4 cycles).
   208b2:	20 93 34 00 	sts	0x0034, r18
	sts	NVM_CTRLA, r19      ; Load bitmask into NVM Control Register A, which executes the command.
   208b6:	30 93 cb 01 	sts	0x01CB, r19
	lds	r22, NVM_DATA0      ; Load NVM Data Register 0 into R22.
   208ba:	60 91 c4 01 	lds	r22, 0x01C4
	lds	r23, NVM_DATA1      ; Load NVM Data Register 1 into R23.
   208be:	70 91 c5 01 	lds	r23, 0x01C5
	lds	r24, NVM_DATA2      ; Load NVM Data Register 2 into R24.
   208c2:	80 91 c6 01 	lds	r24, 0x01C6
	clr	r25                 ; Clear R25 in order to return a clean 32-bit value.
   208c6:	99 27       	eor	r25, r25
	ret
   208c8:	08 95       	ret

000208ca <SP_CommonLPM>:
; ---

.section .text		

SP_CommonLPM:
	movw	ZL, r24             ; Load index into Z.
   208ca:	fc 01       	movw	r30, r24
	sts	NVM_CMD, r20        ; Load prepared command into NVM Command register.
   208cc:	40 93 ca 01 	sts	0x01CA, r20
	lpm	r24,Z
   208d0:	84 91       	lpm	r24, Z+
	ret
   208d2:	08 95       	ret

000208d4 <SP_CommonSPM>:
; ---

.section .text, "ax"

SP_CommonSPM:
	movw	ZL, r24          ; Load R25:R24 into Z.
   208d4:	fc 01       	movw	r30, r24
	sts	NVM_CMD, r20     ; Load prepared command into NVM Command register.
   208d6:	40 93 ca 01 	sts	0x01CA, r20
	ldi	r18, CCP_SPM_gc  ; Prepare Protect SPM signature in R18
   208da:	2d e9       	ldi	r18, 0x9D	; 157
	sts	CCP, r18         ; Enable SPM operation (this disables interrupts for 4 cycles).
   208dc:	20 93 34 00 	sts	0x0034, r18
	spm                      ; Self-program.
   208e0:	e8 95       	spm
	clr	r1               ; Clear R1 for GCC _zero_reg_ to function properly.
   208e2:	11 24       	eor	r1, r1
	out	RAMPZ, r19       ; Restore RAMPZ register.
   208e4:	3b bf       	out	0x3b, r19	; 59
	ret
   208e6:	08 95       	ret

000208e8 <__mulsi3>:
   208e8:	62 9f       	mul	r22, r18
   208ea:	d0 01       	movw	r26, r0
   208ec:	73 9f       	mul	r23, r19
   208ee:	f0 01       	movw	r30, r0
   208f0:	82 9f       	mul	r24, r18
   208f2:	e0 0d       	add	r30, r0
   208f4:	f1 1d       	adc	r31, r1
   208f6:	64 9f       	mul	r22, r20
   208f8:	e0 0d       	add	r30, r0
   208fa:	f1 1d       	adc	r31, r1
   208fc:	92 9f       	mul	r25, r18
   208fe:	f0 0d       	add	r31, r0
   20900:	83 9f       	mul	r24, r19
   20902:	f0 0d       	add	r31, r0
   20904:	74 9f       	mul	r23, r20
   20906:	f0 0d       	add	r31, r0
   20908:	65 9f       	mul	r22, r21
   2090a:	f0 0d       	add	r31, r0
   2090c:	99 27       	eor	r25, r25
   2090e:	72 9f       	mul	r23, r18
   20910:	b0 0d       	add	r27, r0
   20912:	e1 1d       	adc	r30, r1
   20914:	f9 1f       	adc	r31, r25
   20916:	63 9f       	mul	r22, r19
   20918:	b0 0d       	add	r27, r0
   2091a:	e1 1d       	adc	r30, r1
   2091c:	f9 1f       	adc	r31, r25
   2091e:	bd 01       	movw	r22, r26
   20920:	cf 01       	movw	r24, r30
   20922:	11 24       	eor	r1, r1
   20924:	08 95       	ret

00020926 <__udivmodhi4>:
   20926:	aa 1b       	sub	r26, r26
   20928:	bb 1b       	sub	r27, r27
   2092a:	51 e1       	ldi	r21, 0x11	; 17
   2092c:	07 c0       	rjmp	.+14     	; 0x2093c <__udivmodhi4_ep>

0002092e <__udivmodhi4_loop>:
   2092e:	aa 1f       	adc	r26, r26
   20930:	bb 1f       	adc	r27, r27
   20932:	a6 17       	cp	r26, r22
   20934:	b7 07       	cpc	r27, r23
   20936:	10 f0       	brcs	.+4      	; 0x2093c <__udivmodhi4_ep>
   20938:	a6 1b       	sub	r26, r22
   2093a:	b7 0b       	sbc	r27, r23

0002093c <__udivmodhi4_ep>:
   2093c:	88 1f       	adc	r24, r24
   2093e:	99 1f       	adc	r25, r25
   20940:	5a 95       	dec	r21
   20942:	a9 f7       	brne	.-22     	; 0x2092e <__udivmodhi4_loop>
   20944:	80 95       	com	r24
   20946:	90 95       	com	r25
   20948:	bc 01       	movw	r22, r24
   2094a:	cd 01       	movw	r24, r26
   2094c:	08 95       	ret

0002094e <__udivmodsi4>:
   2094e:	a1 e2       	ldi	r26, 0x21	; 33
   20950:	1a 2e       	mov	r1, r26
   20952:	aa 1b       	sub	r26, r26
   20954:	bb 1b       	sub	r27, r27
   20956:	fd 01       	movw	r30, r26
   20958:	0d c0       	rjmp	.+26     	; 0x20974 <__udivmodsi4_ep>

0002095a <__udivmodsi4_loop>:
   2095a:	aa 1f       	adc	r26, r26
   2095c:	bb 1f       	adc	r27, r27
   2095e:	ee 1f       	adc	r30, r30
   20960:	ff 1f       	adc	r31, r31
   20962:	a2 17       	cp	r26, r18
   20964:	b3 07       	cpc	r27, r19
   20966:	e4 07       	cpc	r30, r20
   20968:	f5 07       	cpc	r31, r21
   2096a:	20 f0       	brcs	.+8      	; 0x20974 <__udivmodsi4_ep>
   2096c:	a2 1b       	sub	r26, r18
   2096e:	b3 0b       	sbc	r27, r19
   20970:	e4 0b       	sbc	r30, r20
   20972:	f5 0b       	sbc	r31, r21

00020974 <__udivmodsi4_ep>:
   20974:	66 1f       	adc	r22, r22
   20976:	77 1f       	adc	r23, r23
   20978:	88 1f       	adc	r24, r24
   2097a:	99 1f       	adc	r25, r25
   2097c:	1a 94       	dec	r1
   2097e:	69 f7       	brne	.-38     	; 0x2095a <__udivmodsi4_loop>
   20980:	60 95       	com	r22
   20982:	70 95       	com	r23
   20984:	80 95       	com	r24
   20986:	90 95       	com	r25
   20988:	9b 01       	movw	r18, r22
   2098a:	ac 01       	movw	r20, r24
   2098c:	bd 01       	movw	r22, r26
   2098e:	cf 01       	movw	r24, r30
   20990:	08 95       	ret

00020992 <_exit>:
   20992:	f8 94       	cli

00020994 <__stop_program>:
   20994:	ff cf       	rjmp	.-2      	; 0x20994 <__stop_program>
